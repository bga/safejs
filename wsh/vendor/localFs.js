    -> fso.GetFile(unixPathToNativePath(p.path)).Attributes & 1 != 0fix fso = new nativeGlobal.ActiveXObject(`Scripting.FileSystemObject`)fix FileImpl = Class(File, {  setName: #(p, name) {    assert(p.getIsExist())    fso.GetFile(unixPathToNativePath(p.path)).Name = name  }  getIsExist: #(p) {    -> fso.IsFileExists(unixPathToNativePath(p.path))  }  create: #(p) {    if(!p.getIsExist()) {      p.getParentFolder().create()      fso.OpenTextFile(unixPathToNativePath(p.path), 2, yes, 0)      fso.Close()    }  }  getSymLinkTarget: #(p) {    assert(p.getIsExist())    abstract  }  })fix FolderImpl = Class(Folder, {  setName: #(p, name) {    assert(p.getIsExist())    fso.GetFolder(unixPathToNativePath(p.path)).Name = name  }  getIsExist: #(p) {    -> fso.IsFolderExists(unixPathToNativePath(p.path))  }  create: #(p) {    var path = unixPathToNativePath(p.path)    fix parts = path.split(`\`)    assert(parts.length > 0)    # skip disk    var i = 1    loop {      if(i == parts.length + 1) {        break      }      if(!fso.FolderExists(parts.slice(0, i).join(`\`))) {        break      }      i  = $f + 1    }    if(i < parts.length + 1) {      for(j: i >> parts.length + 1) {        fso.CreateFolder(parts.slice(0, j).join(`\`))      }    }  }  getSymLinkTarget: #(p) {    assert(p.getIsExist())    # ntfs reparse point as folder symlink/mount point     # { fsutil } tool for del and query    fix fsUtilInfo = runShell(eval(tml(`fsutil.exe reparsepoint query "{ unixPathToNativePath(path) }"`)))    if(fsUtilInfo.stdOut.match(/^Error:/)) {      -> null    }    else {      # find binary dump out      fix p = fsUtilInfo.stdOut.match(/^Reparse Data :/).index      # and parse      fix hexes = (fsUtilInfo.stdOut.slice($p.indexOf(eol, p))        .split(eol)        .map(#(line) {          # cut address and ascii data          -> line.match(/^[\da-f]+:(([\da-f]+{2}\s+){8})/)[1]        })        .join(``)      )      fix wideString = (hexes        .trim()        .split(/\s+/)        .map(#(hex) {          -> String.fromCharCode(nativeGlobal.parseInt(hex, 16))        })      )      using(wideStringMixin)      fix unicodeString = wideString.asWideStringToUnicodeString()      -> unicodeString.slice(0, $p.indexOf(String.fromCharCode(0)))    }  }  symlink: #(p, out: Folder, name ?= p.getName()) {    fix outFolderPath = out.path + name + `/`    # { mklink } is build in tool for windows vista or highter and and ntfs 4.0+    ? test it    //runShell(eval(tml(`mklink "{ unixPathToNativePath(outFolderPath.slice(0, -1)) }" "{ unixPathToNativePath(p.path.slice(0, -1)) }" `)))    # { junction } (not build in) tool for create and del     runShell(eval(tml(`junction "{ unixPathToNativePath(outFolderPath.slice(0, -1)) }" "{ unixPathToNativePath(p.path.slice(0, -1)) }" `)))    fix outFolder = p.fs.Folder.new(){      $.fs = p.fs      $.path = outFolderPath    }    if(outFolder.getIsExist()) {      -> outFolder    }    else {      -> null    }  }})export Class(Fs, {  constructor: #(p) {    p.File = FileImpl  }})