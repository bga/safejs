export #(p) {  p.data = {  }}Self.prototype.parseFromString = #(p, s) {  -> Self.new(){    $.data = globalEval(`(` + String(s) + `)`)  }}Self.prototype.toString = #(p, ind = ``) {  fix iter = #(obj, ind) {    fix escapeCString = #(s) {      -> (`"` + (s          .replace(/\n/g, `\n`)          .replace(/\r/g, `\r`)          .replace(/\"/g, `\"`)           .replace(/[\x00-\x19\x80-\xFF]/g, #(char) {            -> `\x` + (`00` + char.charCodeAt(0).toString(16)).slice(-2)          })           .replace(/[\u0100-\uFFFF]/g, #(char) {            -> `\u` + (`0000` + char.charCodeAt(0).toString(16)).slice(-4)          })         )        + `"`      )    }    if(obj == null) {      -> `null`    }    else {      when(obj) {        is(Number) {          if(nativeGlobal.isFinite($)) {            -> $          }          else {            -> `null`          }        }        is(String) {          -> escapeCString($)        }        is(Boolean) {          -> $        }         is(Array) {          -> (`[`             + ($              .map(#(v) {                -> iter(v, ind + `  `)              })              .join(`, `)            )            + `]`          )        }        else {          -> (`{` + eol             + (Object.keys($)              .map(#(k) {                -> ind + `  ` + escapeCString(k) + `: ` + iter($[k], ind + `  `)              })              .join(`,` + eol)            )            + eol + ind + `}`          )        }      }    }  }  -> iter(p.data, ind)}